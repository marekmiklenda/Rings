# Ring 0 – input ring
# Ring 1 – counters
# Ring 2 – constants
# Ring 3 – output ring
mkr 15
mkr 2
mkr 3
mkr 15

put 2 1
rot 2 1
inp 1
put 0 15
sub 0 1 2
rot 2 1
swp 1 2
# Clear the 15 in ring 0
put 0 0

# Load in values from stdin
:loop_a
rot 0 1
inp 0
rot 2 1
add 1 2 1
rot 2 2
jlt 1 2 :loop_a

# Test if there are exactly 15 elements in the input
put 1 0
rot 2 2
jeq 1 2 :skip_garbage_fill

# Fill the remaining space in the array with 255
:loop_b
rot 0 1
put 0 255
rot 2 2
add 1 2 1
rot 2 1
jlt 1 2 :loop_b
:skip_garbage_fill

# Data loading done.
# The entire input array is sitting on ring 0, empty spaces are filled with 255
# Now we'll put 255 as the "lowest" value and search Ring 0 for the smallest value
put 2 15
put 1 0

# For every item in the array
:loop_c
# Make sure that 1 is set to the correct counter
rot 1 1
put 3 255

# For every item in the array (nested loop)
:loop_c_inner
jgt 0 3 :loop_c_inner_block_skip
swp 3 0
:loop_c_inner_block_skip
rot 0 1
rot 2 2
add 1 2 1
rot 2 1
jlt 1 2 :loop_c_inner
rot 3 1

put 1 0
rot 1 1
rot 2 2
add 1 2 1
rot 2 1
jlt 1 2 :loop_c

# Sorted. Display
# The program doesn't need to first sort the values internally and then output them. Instead, it could emit them as it found them.
put 1 0
rot 2 1

:loop_4
out 3
rot 3 1
rot 2 1
add 1 2 1
rot 2 2
jlt 1 2 :loop_4